# 리플렉션
> - 클래스가 제공하는 다양한 정보를 런타임에 동적으로 분석하고 조작하는 기능

## 종류
#### 1. **클래스 메타데이터:**
- 클래스 
```java
//1. 클래스에서 찾기
Class<BasicData> basicDataClass = BasicData.class;  
System.out.println("basicDataClass1 = " + basicDataClass);
// basicDataClass1 = class reflection.data.BasicData  
  
//2. 인스턴스에서 찾기  
BasicData basicInstance = new BasicData();  
Class<? extends BasicData> basicDataClass2 = basicInstance.getClass();  
System.out.println("basicDataClass2 = " + basicDataClass2);  
//basicDataClass2 = class reflection.data.BasicData
  
//3. 문자로 찾기  
String className = "reflection.data.BasicData";  
Class<?> basicDataClass3 = Class.forName(className);  
System.out.println("basicDataClass3 = " + basicDataClass3);
//basicDataClass3 = class reflection.data.BasicData
```
- 접근 제어자, 부모 클래스, 구현된 인터페이스 등
	- 접근 제어자 : `public` , `protected` , `default`  ( `package-private` ), `private`
	- 비접근 제어자: `static` , `final` , `abstract` , `synchronized` , `volatile`  등
```java
    Class<BasicData> basicDataClass = BasicData.class;  
    
    System.out.println("basicDataClass.getName() = " + basicDataClass.getName());  
	// basicDataClass.getName() = reflection.data.BasicData
    
    System.out.println("basicDataClass.getSimpleName() = " + basicDataClass.getSimpleName());  
	//basicDataClass.getSimpleName() = BasicData
    
    System.out.println("basicDataClass.getPackage() = " + basicDataClass.getPackage());  
    //basicDataClass.getPackage() = package reflection.data
    
    System.out.println("basicDataClass.getSuperclass() = " + basicDataClass.getSuperclass());  
    //basicDataClass.getSuperclass() = class java.lang.Object
    
    System.out.println("basicDataClass.getInterfaces() = " + Arrays.toString(basicDataClass.getInterfaces()));  
    //basicDataClass.getInterfaces() = []
    
    System.out.println("basicDataClass.isInterface() = " + basicDataClass.isInterface());  
    //basicDataClass.isInterface() = false
    
    System.out.println("basicDataClass.isAnnotation() = " + basicDataClass.isAnnotation());  
    //basicDataClass.isAnnotation() = false
    
    System.out.println("basicDataClass.isEnum() = " + basicDataClass.isEnum());  
    //basicDataClass.isEnum() = false
    
    System.out.println("basicDataClass.getModifiers() = " + basicDataClass.getModifiers());  
    //basicDataClass.getModifiers() = 1
    
    System.out.println(  
       "Modifier.isPublic(basicDataClass.getModifiers()) = " + Modifier.isPublic(basicDataClass.getModifiers()));  
       //Modifier.isPublic(basicDataClass.getModifiers()) = true
       
    System.out.println(  
       "Modifier.toString(basicDataClass.getModifiers()) = " + Modifier.toString(basicDataClass.getModifiers()));  
       //Modifier.toString(basicDataClass.getModifiers()) = public
}
```

#### 2. **필드 정보:**
- 필드의 이름, 타입, 접근 제어자를 확인하고 해당 필드의 값을 읽거나 수정 가능
- `fields()` : 해당 클래스와 상위 클래스에서 상속된 ==모든 public 필드== 반환
- `declaredFields()` 
	- 해당 클래스에서 선언된 모든 필드 반환
	- 접근제어자에 관계 없음
	- 상속된 필드는 포함하지 않음.
```java
Class<BasicData> helloClass = BasicData.class;  
  
System.out.println("====fields()=======");  
Field[] fields = helloClass.getFields();  
for (Field field : fields) {  
    System.out.println("field = " + field);  
}  
/*
====fields()=======
field = public java.lang.String reflection.data.BasicData.publicField
*/
  
System.out.println("declaredFields()=======");  
Field[] declaredFields = helloClass.getDeclaredFields();  
for (Field declaredField : declaredFields) {  
    System.out.println("declaredField = " + declaredField);  
}
/*
declaredFields()=======
declaredField = public java.lang.String reflection.data.BasicData.publicField
declaredField = private int reflection.data.BasicData.privateField
*/
```
#### 3. 필드 값 동적 변경
```java
var user = new User("id1", "user1", 20);
System.out.println("기존 이름 = " + user.getName());
//기존 이름 = userA

Class<? extends User> aClass = user.getClass();
//name이라는 필드 조회 but private 접근제어자라 직접 접근해서 값을 변경하는 것은 불가능
Field nameField = aClass.getDeclaredField("name");

// private 필드에 접근 허용, private 메서드도 이렇게 호출 가능        
nameField.setAccessible(true);         
nameField.set(user, "userB");         
System.out.println("변경된 이름 = " + user.getName());
// 변경된 이름 = userB
```
>[!Caution]
> - 리플렉션을 사용하면 private 접근 제어자도 직접 접근해서 값을 변경 가능
> - 이러한 접근 제한을 무시하는 것은 캠슐화 및 유지보수에 악영향
> - 신중하게 접근해야하고, getter,setter를 사용해야함
> - 일반적인 앱 코드에선 권장되지 않음.

>[!Note]
> - 공통된 문제 해결할 때 사용 가능 ex) null인값 0으로 채우기 ..
> ```java
> public static void nullFieldToDefault(Object target) throws IllegalAccessException {         
> Class<?> aClass = target.getClass();         
> Field[] declaredFields = aClass.getDeclaredFields();    
>      
> for (Field field : declaredFields) {             
> 	field.setAccessible(true);             
> 	if (field.get(target) != null) {                 
> 		continue;             
> 	}             
> 	
> 	if (field.getType() == String.class) {
> 	       field.set(target, "");            
>      } else if (field.getType() == Integer.class) {                         
> 	     field.set(target, 0);             
>      }         
>    }     
>}
> ```

#### 4. **메서드 정보**
- 메서드 이름, 반환 타입, 매개변수 정보를 탐색하고, 실행 중에 동적으로 메서드 호출 가능
- `getMethods()` :  해당 클래스와 상위 클래스에서 상속된 ==모든 public 메서드 반환==
- `getDeclaredMethods()` : 
	- 해당 클래스에서 선언된 모든 메서드를 반환
	- 접근제어자 관계 없이 반환
	- 상속된 메서드는 포함되지 않음
```java
Class<BasicData> helloClass = BasicData.class;  
System.out.println("========methods()=======");  
  
Method[] methods = helloClass.getMethods();  
for (Method method : methods) {  
    System.out.println("method = " + method);  
}  
/*
========methods()=======
method = public void reflection.data.BasicData.call()
method = public java.lang.String reflection.data.BasicData.hello(java.lang.String)
method = public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException
method = public final void java.lang.Object.wait() throws java.lang.InterruptedException
method = public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException
method = public boolean java.lang.Object.equals(java.lang.Object)
method = public java.lang.String java.lang.Object.toString()
method = public native int java.lang.Object.hashCode()
method = public final native java.lang.Class java.lang.Object.getClass()
method = public final native void java.lang.Object.notify()
method = public final native void java.lang.Object.notifyAll()
*/

System.out.println("========declaredMethods()=======");  
Method[] declaredMethods = helloClass.getDeclaredMethods();  
for (Method declaredMethod : declaredMethods) {  
    System.out.println("declaredMethod = " + declaredMethod);  
}
/*
========declaredMethods()=======
declaredMethod = public void reflection.data.BasicData.call()
declaredMethod = public java.lang.String reflection.data.BasicData.hello(java.lang.String)
declaredMethod = private void reflection.data.BasicData.privateMethod()
declaredMethod = protected void reflection.data.BasicData.protectedMethod()
*/
```
##### 동적 메서드 호출
- `Method` 객체 사용 
- 다양한 체크 예외가  발생함(아래 코드 생략)
```java
Class<? extends BasicData> helloClass = helloInstance.getClass();        
// 메서드 이름이 String으로 되어 있어 얼마든지 변경 가능 -> 동적 호출
String methodName = "hello";

//메서드 이름, 사용하는 매개변수 타입 전달
//hello라는 메서드 이름에 String 매개변수가 있는 hello(String)을 찾음
Method method1 = helloClass.getDeclaredMethod(methodName, String.class);

// 메서드에 실행할 인스턴스와 인자를 전달하면, 해당 인스턴스의 메서드 수행할 수 있음
Object returnValue = method1.invoke(helloInstance, "hi");
System.out.println("returnValue = " + returnValue);

/*
returnValue = hi hello
*/
```

#### 5. **생성자 정보:**
- 생성자의 매개변수 타입과 개수를 탐색하고, 동적으로 객체를 생성 가능 
- 필드, 메서드와 동일
```java
Class<?> aClass = Class.forName("reflection.data.BasicData");  
  
System.out.println("=========생성자");  
Constructor<?>[] constructors = aClass.getConstructors();  
for (Constructor<?> constructor : constructors) {  
    System.out.println(constructor);  
}  
/*
=========생성자
public reflection.data.BasicData()
*/
  
System.out.println("========declaredConstructor");
Constructor<?>[] declaredConstructors = aClass.getDeclaredConstructors();  
for (Constructor<?> declaredConstructor : declaredConstructors) {  
    System.out.println(declaredConstructor);  
}
/*
========declaredConstructor
public reflection.data.BasicData()
private reflection.data.BasicData(java.lang.String)
*/
```
