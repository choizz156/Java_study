
---
#### ThreadPoolExecutor
- 병렬성으로 처리 성능을 극대화하고 동시성으로 cpu 자원을 효율적으로 운용
- 여러 개의 작업을 처리

```mermaid
flowchart LR
    subgraph CPU1 [CPU]
        T1[Thread 1]
        T2[Thread 2]
    end

    subgraph CPU2 [CPU]
        T3[Thread 3]
        T4[Thread 4]
    end

    %% Thread 1 Tasks
    T1 --> A1[Task]
    A1 --> A2[Task]
    A2 --> A3[Task]
    A3 --> A4[Task]

    %% Thread 2 Tasks
    T2 --> B1[Task]
    B1 --> B2[Task]
    B2 --> B3[Task]
    B3 --> B4[Task]

    %% Thread 3 Tasks
    T3 --> C1[Task]
    C1 --> C2[Task]
    C2 --> C3[Task]
    C3 --> C4[Task]

    %% Thread 4 Tasks
    T4 --> D1[Task]
    D1 --> D2[Task]
    D2 --> D3[Task]
    D3 --> D4[Task]

```

#### ForkJoinPool
- 하나의  태스크를 서브 태스크로 분할하여 병렬처리함으로써 전체 작성 성능 높임
![[Pasted image 20250918173900.png]]
---
# Java Thread
- 시스템 콜을 통해서 커널에서 생성된 kernel Thread와 일대일로 매핑되어 최종적으로 커널에서 관리됨
- JVM에서 스레드를 생성할 때마다 커널에서 자바 스레드와 대응하는 커널 스레드 생성

### Thread 구조(메서드)
- 스레드 시작
- 스레드 실행 영역 : 스레드의 실행 메서드는 예외를 던질 수 없음
- 수행중인 스레드 객체 반환
- 활성화 돼있는 스레드 수 반환 
....

### Thread 생성
**Thread 상속**
컴파일 타임에 실행코드가 결정되어 동적인 변경이 불가능
```java
public class Test extends Thread{
	
	@Override
	public void run(){
	
	}
}
Thread thread = new Test();
thread.start()
```

**Runnable 인터페이스 구현**
작업내용을 Runnable에 의해 정의해서 스레드에 전달하면 스레드는 Runnable을 실행
	- 유연하고 확장가능함
```java
public class Test implements Runnable{
	
	@Override
	public void run(){
	
	}
}
Test test = new Test();
Thread thread = new Thread(task);
thread.start()
```

**기타 방법**
- Runnable 익명 클래스
	```java
	new Thread(new Runnable(){
		@Override
		public void run(){
		}
	})
	```
- 람다 사용
```java
new Thread(() -> {
	//내용
}).start()
```

## 1. Thread 실행/종료
- OS 스케줄러에 의해 실행 순서가 결정되며 JVM에서 제어 불가
- 새로운 스레드는 현재 스레드와 독립적으로 실행, 최대 한 번 시작 가능하고 스레드가 종료된 후 다시 시작 불가능

### 1.1 실행
#### start()
- 스레드를 실행시키는 메서드로 시스템 콜을 통해서 커널 스레드 생성 요청

**Thread 생성 과정**
1. 메인 스레드가 새로운 스레드를 생성
2. start를 호출해서 실행 시작
3. 내부적으로 네이티브 메서드를 호출해서 커널 스레드를 생성하도록 시스템 콜
4. 커널 스레드와 자바 스레드가 일대일 매핑
5. 커널 스레드는 os 스케쥴러로 부터 cpu 할당을 받기 까지 실행 대기 상태
6. 커널 스레드가 스케쥴러에 의해 실행상태가 되면 jvm에 매핑 된 자바 스레드의 run 메서드 호출

#### run()
- 스레드가 실행(start) 되면 해당 스레드에 의해 자동으로 호출되는 메서드
>[!Caution]
> run 메서드를 직접 호출 -> 새로운 스레드가 생성 x, 직접 호출한 스레드의 실행 스택에서 run이 실행

### 1.2 Thread 스택
- 스레드가 생성되면, 해당 스레드를 위한 스택이 같이 만들어짐
- 스택은 각 스레드마다 독립적으로 할당 -> 스레드간 접근하거나 공유할 수 없음

**stack 구성**
- 프레임(Frame)으로 구성
- 새 메서드를 호출할 때마다 로컬 변수 및 객체 참조 변수와 함께 스택의 맨위에 생성
- 실행 완료 후 스택 프레임 제거 

**stack 메모리 상태 관리**
- 스택 내부의 변수는 메서드가 실행되는 동안에만 존재
- 힙과 비교할 때 접근이 빠름

### 1.3 Thread 종료
- run 메서드가 모두 실행되면 스레드는 자동 종료
- 예외가 발생할 경우 종료, 다른 스레드에 영향을 미치지 않음

**싱글스레드**
- main 스레드만 종료되면 앱이 종료

**멀티스레드**
- jvm에서 실행하고 있는 모든 스레드가 종료되어야 어플리케이션이 종료(데몬 스레드 제외)
- 스레드 종료 시점은 os에서 결정하므로 매번 다르게 나올 수 있음
