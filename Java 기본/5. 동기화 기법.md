## 1. Mutual Exclusion(뮤텍스)
- 공유 자원에 대한 경쟁 상태를 방지
- 동시성 제어를 위한 락 메커니즘
- Mutex 락을 가진 오직 한 개의 스레드만이 임계영역에 진이발 수 있으며 락을 획득한 스레드만이 락을 획득
	- 스레드가 임계영역에서 **Mutex 객체의 플래그**를 소유하고 있으면 다른 스레드가 엑세스 할 수 없음.
	- **Mutex 객체의 플래그**가 해제된 경우에만 액세스 할 수 있음

### 1.1문제점
#### 데드락
- 두 개 이상의 스레드가 서로 가진 락을 기다리면서 블로킹되어 아무 작업도 수행할 수 없는 상태
#### 우선 순위 역전
- 높은 우선 순위를 가진 스레드가 낮은 우선 수누이를 가진 스레드가 보유한 락을 기다리는 동안 블록되는 현상
#### 오버헤드
- 여러 스레드가 경합하면서 락을 얻기 위해 스레드 스케쥴링이 발생 -> 오버헤드 발생
#### 성능 저하
- 락을 얻기 위해 스레드가 대기, 스레드 실행 시간이 블록되면서 성능 저하
#### 오사용
- 잘못된 순서로 락을 해제하는 경우 예기치 않은 동작이 발생할 수 있음
---
## 2. Semaphore
- 공유 자원에 대한 접근을 제어하기 위해 사용되는 신호 전달 메커니즘
- 정수형 변수 `S`와 `P(Proberen: try)`, `V(Verhogen: increment)` 두 가지 원자적 함수로 구성됨
	- P는 임계 영역을 사용하려는 스레드의 진입 여부를 결정하는 연산(Wait 연산)
	- V는 대기 중인 프로세스를 깨우는 신호(Signal 연산)
	

>[!Note]
>- 자바에서는 java.util.concurrent 패키지에 semaphore를 포함하고 있기 때문에 직접 구현할 필요는 없음

### 2.1 세마포어 작동 방식


| 구분     | S                                | P 연산 (Wait 연산)                          | V 연산 (Signal 연산)                        |
| ------ | -------------------------------- | --------------------------------------- | --------------------------------------- |
| **의미** | 정수형 변수                           | S가 1 감소 (S--)                           | S가 1 증가 (S++)                           |
| **설명** | 공유 자원의 개수로서 이 개수만큼 스레드의 접근이 허용된다 | 스레드가 임계 구역에 진입하기 전 실행되어 카운트의 값을 1 감소시킨다 | 스레드가 임계 구역에서 빠져나올 때 실행되어 카운트 값을 1 증가시킨다 |
#### 동기화
- S가 0보다 크면 공유자원 접근이 허용되며 S가 0이면 공유 자원 접근이 거부됨
- 같은 세마포어의 P, V 함수의 S연산은 여러 스레드 간 동시에 실행이 되지 않도록 원자적 실행이 보장돼야함

### 2.2 유형
#### 이진 세마포어
- 카운트 변수 S가 1인 세마포어
- 뮤텍스처럼 락으로 사용하기 위해선, 카운트 변수를 1로 설정하고 한 스레드 안에서 세마포어를 획득하고 해제할 수 있도록 함
#### 카운팅 세마포어
- 카운트 변수가 2 이상인 세마포어
- 스레드가 공유할 수 있는 자원의 최대치를 한정해서 운용하는 방식으로 **자원 pool이나 컬렉션 크기 제한을 두고자 할 때 유용**
- 락을 획득한 스레드와 락을 해제하는 스레드는 다를 수 있음
- 스레드 간 락과 락 해제를 위한 신호를 전달함으로써 동기화 구현
- 어느 스레드를 먼저 수행해도 항상 ==Signal -> Wait== 순서로 실행됨


```java
pulic class Test{
	
	private static Semaphore semaphore = new Semaphore(3);
}
```


### 2.3 뮤텍스와 세마포어
#### 동작 방식
- 뮤텍스: 공유 자원에 대한 접근을 동시에 하나의 스레드만 가능하도록 함
- 세마포어: 
	- 카운팅 기법으로, 특정 개수의 스레드가 도잇에 공유 자원에 접근할 수 있도록 제어(카운팅 세마포어)
	- 이진 세마포어는 뮤텍스와 유사한 역할 가능
#### 소유권
- 뮤텍스: 락을 획득한 스레드만이 락을 해제 가능, 다른 스레드는 해당 뮤텍스에 접근할 수 없음
- 세마포어: 
	- 소유권이 없음, 
	- 특정 개수의 스레드가 동시에 접근을 허용할 수 있음
	- 세마포어를 사용하는 스레드들이 모두 세마포어를 해제할 수 있음
#### 초기값
- 뮤텍스: 기본적으로 잠금상태로 시작
- 세마포어: 초기값을 설정할 수 있으며 처음부터 접근가능한 스레드를 설정 가능

#### 사용 목적
- 뮤텍스: 상호 배제를 위해 사용, 하나의 스레드만 접근하도록 보장해야 하는 경우
- 세마포어: 리소스의 한정적인 사용을 제어, 특정 개수의 스레드만이 도잇에 자원에 접근하도록 제한

>[!Note]
>- Java는 뮤텍스를 고도화한 Monitor 객체와 Semaphore를 구현체를 제공하고 있음

---
## 3. Monitor(모니터)
- 자바의 기본적인  동기화 메니즘
	- 뮤텍스나 세마포어보다 더 고수준의 동기화
- 모든 자바 객체는 기본적으로 모니터와 연관될 수 있음
	- JVM은 **필요할 때 (즉, 객체가 동기화에 사용될 때)** 모니터를 **지연 생성(lazily initialized)**
	- 여러 스레드가 임계영역으로 진입하려할때, JVM은 모니터를 사용하여 스레드간 동기화 제공
- 자바의 모니터는 **상호 배제** 협력이라는 두 가지 동기화 기능을 제공하며 뮤텍스와 조건 변수를 사용함

### 3.1 상호 배제
- **synchronized** 키워드를 통해 뮤텍스 동기화를 암묵적으로 처리
	- synchronized 블록은 해당 객체의 모니터를 획득할 수 있으며 모니터를 획득한 스레드만이 임계영역 접근 가능, 나머지는 블록
	- 블록을 빠져나요면 lock 해제되고 다음 스레드가 lock을 얻음

### 3.2 협력(Cooperation)
- 모니터의 **조건 변수(객체타입)** 를 통해 스레드 간 공동의 목표를 위해 상호협력으로 데이터의 일관성과 안정성을 보장하는 동기화 메커니즘
- **Conditional Variable**
	- 모니터 내부에서 **특정 조건이 만족될 때까지 스레드를 일시 정지(wait)** 시키거나,  **조건이 만족되면 대기 중인 스레드를 깨우는(notify)** 메커니즘
- 조건 변수를 통해 스레드간 대기와 통지를 서로 조절하면서 경쟁 조건과 같은 문제 방지 가능
- 자바는 모니터 당 **오직 하나의 조건변수**를 가질 수 있음

### 3.3 모니터 대기 셋 구조
- 자바의 모니터 내부에는 EntrySet과 WaitSet이라는 자료구조가 있음
#### Entry Set
- lock을 획득하기 위해 대기 중인 스레드들을 모아 놓은 자료 구조
- lock이 반납될 때 까지 기다리며 락이 반납되면 Entry Set 중 하나의 스레드가 락을 획득하고 임계 영역으로 진입하게 됨

#### Wait Set
- 모니터의 조건 변수와 함께 사용하는 자료구조, 스레드들이 특정한 조건이 만족할 때 까지 대기하고 있는 장소
- 스레드는 Wait Set에 들어가 대기할 때 lock을 해제하고, 다른 스레드에 의해 깨어나게 되면 Entry Set으로 이동해서 다시 lock을 해제 가능

### 3.4 조건 변수 종류

####  Signal-and-Wait 모델 (모니터 락을 넘겨주는 방식)

**개념**
- 깨우는 스레드가 `notify()`를 호출하면,  즉시 락을 **반납하고(wait 상태로 들어가)** 깨어난 스레드가 락을 얻어 작업을 이어감
- 즉, **신호를 보낸 스레드가 먼저 기다리고**, 깨어난 스레드가 즉시 실행
    
**특징**
- 깨어난 스레드가 먼저 실행되므로 **지연이 적고 응답성이 좋음**
- 하지만 **원자성 보장 및 구현 복잡도**가 높습니다.
- 대표적 사용 언어: 일부 **이론적 모니터 모델(예: Hoare Monitor)**
#### Signal-and-Continue 모델 (자바가 사용하는 방식)

**개념**
- 깨우는 스레드가 `notify()`를 호출해도 **락을 계속 보유**합니다.
- 깨어난 스레드는 **Entry Set으로 이동**하여, 락이 해제될 때까지 대기합니다.
- 깨우는 스레드가 자신의 작업을 모두 끝내고 락을 해제해야,  
    그제서야 깨어난 스레드가 락을 얻고 실행할 수 있습니다.
    
**특징**
- 구현이 단순하고 안정적 (모니터 락의 소유권이 즉시 바뀌지 않음)
- 깨어난 스레드가 즉시 실행되지 않아 약간의 **지연(latency)** 이 존재
- 대표적 사용 언어: ✅ **Java, C#, Python**
    
#### 자바의 실제 동작 정리

1. `wait()`
    - 현재 스레드는 모니터 락을 해제하고 `Wait Set`으로 이동
    - `notify()` 또는 `notifyAll()`이 호출될 때까지 대기
        
2. `notify()` / `notifyAll()`
    - `Wait Set`에 있는 스레드 중 하나(또는 전체)를 **깨움**
    - 하지만 **락은 여전히 notify를 호출한 스레드가 보유**
    - 깨워진 스레드는 `Entry Set`으로 이동하여 **락을 기다림**
        
3. 락이 해제되면 (`synchronized` 블록 종료 시점)
    - `Entry Set`의 스레드들이 락을 경쟁하여 획득
    - 획득한 스레드가 실행 재개

![[Pasted image 20251019193935.png]]

---
## 4. SpinLock과 Busy Waiting

### 4.1 SpinLock
- 스레드가 기다리지 않고 임계영역을 **사용할 수 있을때 까지** 계속 반복하여 검사하는 동기화 메커니즘
- 스핀락을 얻을때 까지 계속해서 반복적으로 검사를 수행(ex. while문 사용)
- Busy Wating을 사용함.
### 4.2 Busy Waiting
- 스레드가 **어떤 조건이 만족할 때 까지** 계속해서 반복적으로 검사함
- 스레드가 특정 조건을 기다리는 동안 무한 반복 루프를 돌며 cpu 자원을 계속 사용함.
```java
public class SpinLockClass{
	
	private AtomicBoolean lock = new AtomicBoolena(false);
	
	public void lock(){
		while(!lock.compareAndSet(false, true)){
		}
	}
	
	public void unlock(){
		lock.set(false);
	}
}
```

### 4.3 SpinLock 장단점
#### 장점

1. **컨텍스트 스위칭 비용 감소**
    - 뮤텍스(Mutex)나 세마포어(Semaphore)는 블로킹 시 컨텍스트 스위칭이 발생하지만, 스핀락은 블로킹하지 않고 반복 검사(busy waiting)로 대기 → 전환 비용이 없음.

2. **짧은 임계 구역(critical section)에서 유리**
    - 공유 자원 점유 시간이 짧다면, 스핀락으로 빠르게 접근 가능.
    - 컨텍스트 스위칭보다 임계 구역 대기 시간이 짧을 때 성능 이점이 있음.
        
####  단점

1. **CPU 리소스 낭비**
    - 자원이 사용 중이면 스레드가 계속 루프를 돌며 CPU를 점유 → 낭비 발생.
        
2. **경쟁이 많은 환경에서는 비효율적**
    - 대기 시간이 길거나 여러 스레드가 동시에 접근하려 하면 오히려 성능 저하.
        
3. **싱글코어 환경에서는 부적합**
    - 하나의 코어를 점유한 스레드가 busy waiting으로 다른 스레드의 실행을 막음 → 데드락 유발 가능.
>[!Caution]
>- **멀티코어 환경**에서, **임계 구역이 매우 짧고 경쟁이 적은 경우**에만 사용하는 것이 효과적.
>- 그 외 대부분의 경우에는 **뮤텍스나 세마포어 같은 블로킹 기반 동기화 기법**이 더 적합함.

    