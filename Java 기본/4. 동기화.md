## 1. 싱글 스레드, 멀티 스레드

### 1.1 싱글 스레드
#### 장점
- 컨텍스트 스위칭이 없음
- 동기화 이슈가 없음
- 자원 비용이 적음
- 프로그래밍 난이도 낮음

#### 단점
- cpu 멀티코어 활용 못함
- 순차적 실행으로 응답성 및 전체 처리량이 낮음
- I/O 처리 시 cpu 낭비
- 스레드에 오류가 발생하면 프로그램이 종료됨.

### 1.2 멀티 스레드

#### 장점
- 동시성으로 사용자의 응답성 향상
- CPU 멀티코어의 병렬성으로 성능 향상
- CPU 낭비 없는 자원의 효율적인 사용
- 한 스레드의 오류는 다른 스레드에 영향 없음

#### 단점
- 빈번한 문맥교환 시 성능이 저하
- 스레드 간 동기화 이슈
- 스레드 생성 비용은 작지 않음
- 프로그래밍 난이도가 높음

>[!Note]
>- 현대는 대부분 멀티코어를 지원하기 때문에 병렬적 성능 및 동시적 자원 사용 관점에서 멀티 스레드 기반 프로그래밍이 유리
>- 싱글 스레드나 적은 스레드를 활용한 비동기 논블러킹 프로그래밍은 멀티 스레드 기반 프로그래밍보다 좋은 성능과 응답성을 보여줄 수 있음.

#### 멀티 스레딩과 동시성 문제
- 여러 스레드가 읽기 및 쓰기 작업을 같은 메모리 영역에서 동시에 실행할 경우 동시성 문제가 대두
**동시성 문제**
- 하나의 스레드가 어떤 메모리 영역의 데이터를 쓰고 있는데, 또 다른 스레드가 같은 메모리 영역의 데이터를 읽거나 쓸 경우 발생할 수 있는 문제

---
## 2. 동기화
프로세스나 스레드 간 공유 영역에 대한 동시 접근으로 발생하는 데이터 불일치를 막고, 데이터 일관성 유지를 위해 ==순차적으로 공유 영역을 수행하도록 보장하는 메커니즘==

### 2.1 CPU 연산 처리
- cpu가 두 개 이상의 명령어를 처리할 경우, 원장성이 보장되지 않음
- 각 명령을 수행하는 중에 OS가 다른 스케줄링으로 CPU에게 다른 명령을 수행하게 함으로싸 현재 수행 중인 명령을 인터럽트함
- 두 개 이상의 명령어를 원자성으로 묶기 위해서는 스레드 간 동기화 메커니즘이 필요

$$
\begin{array}{c}
\text{START} \\
\downarrow \\
\begin{array}{|c|}
\hline \text{Memory: } data = 0 \\
\hline
\end{array} \\
\downarrow \\
\begin{array}{|c|}
\hline \text{Thread 2 starts execution} \\
\hline
\end{array} \\
\downarrow \\
\begin{array}{|c|}
\hline \text{Thread 2: LOAD R1, data} \\
\text{(R1 $\leftarrow 0$)} \\
\hline
\end{array} \\
\downarrow \\
\begin{array}{|c|}
\hline \text{Thread 2: ADD R1, 1} \\
\text{(R1 $\leftarrow 1$)} \\
\hline
\end{array} \\
\downarrow \\
\begin{array}{|c|}
\hline \textbf{Context Switching} \\
\text{(Thread 2 $\rightarrow$ Wait, Thread 1 $\rightarrow$ Run)} \\
\hline
\end{array} \\
\downarrow \\
\begin{array}{|c|}
\hline \text{Thread 1 starts execution} \\
\hline
\end{array} \\
\downarrow \\
\begin{array}{|c|}
\hline \text{Thread 1: LOAD R1, data} \\
\text{(Reads old value: R1 $\leftarrow 0$)} \\
\hline
\end{array} \\
\downarrow \\
\begin{array}{|c|}
\hline \text{Thread 1: ADD R1, 1} \\
\text{(R1 $\leftarrow 1$)} \\
\hline
\end{array} \\
\downarrow \\
\begin{array}{|c|}
\hline \text{Thread 1: STORE R1, data} \\
\textbf{(Memory: data $\leftarrow 1$)} \\
\hline
\end{array} \\
\downarrow \\
\begin{array}{|c|}
\hline \textbf{Context Switching} \\
\text{(Thread 1 $\rightarrow$ Wait, Thread 2 $\rightarrow$ Run)} \\
\hline
\end{array} \\
\downarrow \\
\begin{array}{|c|}
\hline \text{Thread 2 resumes (R1 is still 1)} \\
\hline
\end{array} \\
\downarrow \\
\begin{array}{|c|}
\hline \text{Thread 2: STORE R1, data} \\
\textbf{(Memory: data $\leftarrow 1$)} \\
\hline
\end{array} \\
\downarrow \\
\begin{array}{|c|}
\hline \textbf{FINAL RESULT: } data = 1 \\
\text{(Expected result: } data = 2) \\
\hline
\end{array} \\
\downarrow \\
\text{END}
\end{array}
$$

---
## 3. Critical Section
- 둘 이상의 스레드가 공유 자원에 접근하는 코드 영역
- 하나의 스레드만 접근해야 함

### 3.1 Critical Section Problem
- 한 스레드가 임계 영역에서 수행 중일 때, 다른 스레드가 임계 영역을 사용함으로서 발생하는 문제

#### 해결 조건 
**3가지**
- `상호 배제`
	- 어떤 스레드가 임계 영역에서 실행중일 경우 다른 스레드는 동일한 임계 영역에서 수행할 수 없음
- `Progress(진행)`
	- 임계 구역에서 실행 중인 스레드가 없고, 임계 구역에 진입하려는 스레드가 있을 때, 어떤 스레드가 들어갈 것인지 적절히 선택해야함
	- 선택이 무한정 미뤄져서는 안됨
- `Bounded Wating(한정 대기)`
	- 다른 스레드가 임계 영역 진입을 요청한 경우, 그 요청이 수락되기 전에 기존 스레드가 임계 영역에서 실행할 수 있는 횟수에는 반드시 제한이 있어야 함

#### 동기화 도구
- 뮤텍스
- 세마포어
- 모니터
- CAS
- synchrozied

### 3.2 Race Condition
- 여러 스레드가 공유 자원에 접근하고 조작하는 상황
- 스레드 간 액세스 순서나 시점에 따라 실행결과가 달라질 수 있음.