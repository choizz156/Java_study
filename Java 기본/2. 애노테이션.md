# Java 애노테이션(Annotation)

## 1. 애노테이션이란?

- **정의**: 코드에 메타데이터를 추가하는 도구 (주석과 유사하지만 실행 시에도 활용 가능)
- **용도**: 코드에 대한 추가 정보를 제공하여 컴파일러나 런타임에서 특별한 처리를 할 수 있도록 함

## 2. 애노테이션 정의 방법

### 기본 문법

```java
@interface 애노테이션명 {
    데이터타입 요소명() default 기본값;
}
```

### 예제

```java
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Retention(RetentionPolicy.RUNTIME)
public @interface BasicMapping { 
    String value();
    int count() default 0;
    String[] names() default {};
    Class<? extends MyLogger> annotationData() default MyLogger.class;
}
```

## 3. 애노테이션 규칙

### 사용 가능한 데이터 타입

- 기본 타입 (int, boolean, char 등)
- String
- Class or Interface
- enum
- 다른 애노테이션 타입
- 위 타입들의 배열

### 제한사항

- **일반 클래스는 사용 불가** (Class 정보는 가능)
```java
// 이런 식으로는 사용할 수 없습니다
public class MyData {
    private String name;
    private int age;
}

public @interface MyAnnotation {
    MyData data();  // ❌ 컴파일 에러! 일반 클래스 타입 사용 불가
}

public @interface MyAnnotation {
    Class<? extends MyLogger> loggerClass() default MyLogger.class;  // ✅ 가능!
    Class<?> targetClass();                                          // ✅ 가능!
    Class<String> stringClass() default String.class;               // ✅ 가능!
}

// 사용 예시
@MyAnnotation(
    loggerClass = ConsoleLogger.class,
    targetClass = UserService.class,
    stringClass = String.class
)
public class MyService {
    // ...
}
```
- `void` 반환 타입 사용 불가
- 예외 선언 불가
- 요소는 메서드 형태로 정의

### 특별한 규칙

- `value`라는 이름의 요소가 하나만 있을 경우, 사용 시 요소 이름 생략 가능
- `default` 키워드로 기본값 지정 가능

## 4. 메타 애노테이션

### @Retention

- 애노테이션의 생존 기간을 지정

```java
@Retention(RetentionPolicy.RUNTIME)   // 런타임까지 유지
@Retention(RetentionPolicy.CLASS)     // 컴파일된 클래스 파일까지 유지 (기본값)
@Retention(RetentionPolicy.SOURCE)    // 소스 코드에만 유지
```

### @Target

- 애노테이션을 적용할 수 있는 위치 지정

```java
@Target(ElementType.METHOD)           // 메서드에만 적용
@Target(ElementType.TYPE)             // 클래스, 인터페이스에 적용
@Target(ElementType.FIELD)            // 필드에 적용
@Target({ElementType.METHOD, ElementType.TYPE}) // 여러 위치에 적용
```

### @Documented

- JavaDoc 생성 시 해당 애노테이션 정보를 포함할지 결정

### @Inherited

- 자식 클래스가 부모 클래스의 애노테이션을 상속받을 수 있게 함
- **클래스 상속에서만 작동** (인터페이스 구현에서는 작동하지 않음)

### 메타 애노테이션 사용 예제

```java
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD, ElementType.TYPE})
@Documented
public @interface AnnoMeta {
    String value() default "";
}
```

## 5. 애노테이션과 상속

### 기본 특징

- 모든 애노테이션은 묵시적으로 `Annotation` 인터페이스를 상속
- 다른 애노테이션이나 인터페이스를 직접 상속할 수 없음
- 상속 개념이 존재하지 않음

### @Inherited의 동작

- 클래스 상속에서만 작동하는 이유:
    - 클래스 상속: 부모의 속성과 메서드를 상속받는 명확한 관계
    - 인터페이스 구현: 시그니처만 정의, 다중 구현 가능으로 충돌 위험

## 6. 자바 기본 애노테이션

### @Override

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {}
```

- **용도**: 메서드 재정의가 올바르게 되었는지 컴파일러가 검증
- **특징**: 컴파일 시점에만 필요하므로 SOURCE 레벨

### @Deprecated

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(value = {CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE})
public @interface Deprecated {
    String since() default "";
    boolean forRemoval() default false;
}
```

- **용도**: 사용을 권장하지 않는 기능 표시
- **사용법**: `@Deprecated(since = "2.4", forRemoval = true)`

### @SuppressWarnings

```java
@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
    String[] value();
}
```

- **용도**: 컴파일러 경고 억제
- **주요 값들**:
    - `"unchecked"`: 제네릭 타입 검사 경고
    - `"unused"`: 사용하지 않는 변수 경고
    - `"deprecation"`: 사용 중단 경고
    - `"rawtypes"`: 원시 타입 사용 경고
    - `"all"`: 모든 경고

## 7. 애노테이션 활용 예제

### 사용자 정의 애노테이션

```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface ValidateInput {
    String message() default "Invalid input";
    boolean required() default true;
}

// 사용
public class UserService {
    @ValidateInput(message = "사용자 이름은 필수입니다", required = true)
    public void createUser(String name) {
        // 구현
    }
}
```

### 리플렉션을 통한 애노테이션 활용

```java
Method[] methods = UserService.class.getDeclaredMethods();
for (Method method : methods) {
    if (method.isAnnotationPresent(ValidateInput.class)) {
        ValidateInput annotation = method.getAnnotation(ValidateInput.class);
        System.out.println("검증 메시지: " + annotation.message());
        System.out.println("필수 여부: " + annotation.required());
    }
}
```

